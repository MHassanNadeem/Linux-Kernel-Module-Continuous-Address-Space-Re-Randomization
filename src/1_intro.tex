
In the earlier days of computing, an attacker could exploit a stack overflow vulnerability fairly easily to take control of the system. For example, an attacker could inject code into a program and deliberately cause a stack overflow to hijack the control flow. This kind of attack is known as a \textit{stack smashing attack} and is one of the oldest and most important exploits used to gain unauthorized access to a system~\cite{pincus2004beyond, PhrackMa67:online}. 

With the advent of \textit{Data Execution Prevention (DEP)}, code injection attacks are no longer possible. However, in spite of security mechanisms such as DEP, programs remain vulnerable to code reuse attacks. In a code reuse attack, an attacker, instead of injecting new code into the memory, now finds code fragments already existing in the program to form an exploit~\cite{Shacham:2007:GIF:1315245.1315313}. Such code fragments are referred to as gadgets. By carefully selecting gadgets, the attacker is able to perform arbitrary actions. These types of attacks, generically called code-reuse attacks, are non-trivial to defend against since the code must be executable for the program to function; nonetheless, out of order execution of code must be prevented.

Code reuse attacks are exemplified by return-oriented programming (ROP). In ROP, the attacker targets a specific program or library. The attacker uses tools such as Ropper~\cite{schirra_2019} to inspect the targeted binary and build an ROP chain to serve their malicious purpose. A ROP chain is a list of gadgets with each ending in a return statement. To perform a ROP attack, an attacker injects the stack with the list of pre-generated code pointers that each point to a gadget. After a gadget finishes execution, the return statement pops the address of the next gadget from the stack into the instruction pointer. This way, the attacker is able to piece together different fragments of code to perform arbitrary actions.

One popular mitigation against code reuse is \textit{Address Space Layout Randomization (ASLR)}~\cite{ASLR,PAXASLR}.
In ASLR, the layout of the program is randomized at load time. With the program layout randomized, each time it is loaded in memory, a traditional ROP attack comprising of pre-computed gadgets is no longer effective. In principle, all code reuse attacks can be prevented by denying the attacker knowledge of the location of code in memory. Unfortunately, an abundance of memory disclosure vulnerabilities makes it possible to defeat ASLR~\cite{cvedetails:online,strackx2009breaking}. In a Just-Tn-Time (JIT) ROP attack, with the help of these vulnerabilities, code pointer leakages can be used to unravel ASLR~\cite{JITROP,ahmed2019methodologies}.


As the sophistication of security attacks and countermeasures grow for user space programs, an operating system kernel experiences a similar increase in the number of attackers. There is an increasing number of kernel vulnerabilities that are discovered in the code of widely deployed commodity operating systems~\cite{LINUXVULN,WINDOWSVULN,MACOSVULN}. Some of the recently discovered Linux vulnerabilities such as CVE-2018-14634 are very serious and seem to have existed for over a decade~\cite{LINUXVULNDECADE}. Vulnerabilities are even more likely to be present in Linux device drivers since they are typically less tested than core kernel components, as each installation uses only a subset of drivers~\cite{cvedetails_kernel}.

There are several reasons why operating system (OS) kernels are attractive to attackers. First and foremost, defense against attacks is typically more challenging in the kernel space, which includes low-level code involving system calls, device drivers, and interrupt handlers. Second, defense mechanisms for kernel space vulnerabilities (and their inclusion in commodity OSes) often lag behind their user space counterparts. A case in point: the Linux kernel limits kernel address space layout randomization (KASLR)~\cite{KASLRLINUX},
a well-known technique against control-flow attacks, to a paltry $1$GB range on x86-64 machines due to architectural limits on instruction immediate operands~\cite{X86ABI,elixir_kernel_range:online}. Exacerbating the problem, an attacker can assume that certain memory addresses are page-aligned, which makes even unsophisticated brute-force attacks feasible.

Furthermore, OS kernel code, especially that of typical OSes in widespread production-use such as Linux, is large and complex. On the one hand, this complicates the design and implementation of defense mechanisms~\cite{ASRMINIX}. One the other hand, it gives
great flexibility for an attacker. In fact, there is a great reward
for an attacker: tampering with the kernel and gaining control of the entire system effectively enables the attacker to bypass many defense mechanisms that are deployed in user space to protect programs.

While there has been significant work done for defense against JIT-RIP and other code reuse attacks in the user space~\cite{SHUFFLER,MEMORYEXPLOIT,Wartell:2012:BSS:2382196.2382216,TASR,lu2016make,chen2017you}, research on kernel space defenses has unfortunately lagged behind. An example of defense for user space is \textit{Shuffler}~\cite{SHUFFLER}. Shuffler operates by continuously randomizing the code of a running process. By denying the knowledge of code location and continuously obsoleting memory leakages, successful formation of JIT-ROP gadgets can be prevented.

This thesis presents a defense mechanism against code-reuse attacks for kernel space, specifically targeting Linux.
Our technique contributes to Linux security in two uniquely distinguishing ways. First, the thesis extends KASLR to 64-bit address range efficiently by using the position-independent code model. Second, the thesis implements continuous re-randomization for kernel modules, an effective technique against just-in-time ROP attacks~\cite{JITROP}. Our technique is specifically designed for kernel space re-randomization and addresses the unique challenges that must be overcome to accomplish it. Unlike prior approaches for continuous re-randomization in user space~\cite{SHUFFLER}, we use a zero-copying method for moving code (and most static data as well). In addition, we efficiently keep track of, and unmap previously used address ranges.

We implement our techniques in the Linux kernel and experimentally evaluate our position-independent code support using \textit{Sysbench}~\cite{web:sysbench} and \textit{Kernbench}~\cite{web:kernbench} benchmarks as well as custom microbenchmarks. We also evaluate the cost of re-randomization for several different device drivers using microbenchmarks and real-life server applications such as Apache and mySQL. Our results reveal very little ($<$ 2\%) overhead for re-randomization compared to vanilla Linux and completely negligible overhead for supporting extended KASLR with position-independent modules.

\section{Thesis Contributions}
The thesis makes the following contributions:
\begin{enumerate}
  \item The thesis extends the range of address space layout randomization. We compile Linux kernel modules using a position-independent model that removes the prior limitation of modules having to be placed within a narrow 1GB region near the core kernel. We have compiled over 5000 modules in Ubuntu 18.04 for our testing. This contribution has already been submitted to one of the Linux kernel mailing lists as a patch, which is currently under review~\ssrgContribution~\cite{pie_patch_2:online, pie_patch_1:online}.
  \item The thesis implements a mechanism for continuous re-randomization of Linux kernel modules.\ssrgEvolution~This work, to the best of our knowledge, is the first working implementation of continuous re-randomization for the Linux kernel.
  \item The thesis demonstrates the practicality of our re-randomization approach. Our experimental studies involving stress-testing popular network and storage drivers show negligible performance impact and robustness of our re-randomization technique.
\end{enumerate}

\section{Thesis Organization}
The remainder of this thesis is organized as follows:
\begin{itemize}
    \item Chapter~\ref{ch:background} provides a background of control-flow attacks and their defenses. The chapter also presents the prerequisite base knowledge for understanding the thesis.
    \item Chapter~\ref{ch:related-word} presents prior work for preventing code reuse attacks on both user-space programs and operating systems.
    \item Chapter~\ref{ch:pic} presents the design and implementation of \textit{position-independent modules}, the first major contribution of the thesis. 
    \item Chapter~\ref{ch:re_randomization} presents the design and implementation of our \textit{re-randomization} technique, the second major contribution of the thesis.
    \item Chapter~\ref{ch:evaluation} experimentally evaluates the techniques presented in the thesis on the basis of their performance, scalability, and security.
    \item Chapter~\ref{ch:conclusion} concludes the thesis by presenting the key insights and discusses avenues for future work.
\end{itemize}