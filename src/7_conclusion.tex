In this thesis, we presented a technique to prevent code-reuse attacks on the Linux kernel modules. We added support for position-independent code model and demonstrated the first-ever implementation of code re-randomization for the Linux kernel modules. Both of these contributions increase the entropy and reduce the chances of a successful ROP attack. Our experiments show that our implementation results in a negligible effect on system performance.

\section{Conclusions}
As discussed in Section~\ref{sec:bg_rop}, \textit{executable space protection} is a computer security technique of marking memory regions as non-executable. The widespread adoption of this technique has virtually eliminated \textit{code injection} attacks on modern systems. Code injection, which was once one of the most important techniques used by attackers to gain unauthorized access to the system, has been replaced by \textit{code reuse attacks}. Code reuse attacks exemplified by \textit{return oriented programming (ROP)} reuse fragments of existing code to perform arbitrary actions and thus avoid the need for injecting code.

\textit{Kernel address-space layout randomization (KASLR)} is a security technique currently employed by the Linux kernel to make successful ROP attacks harder to launch. With KASLR, the kernel and its modules are loaded at random addresses at boot time. This defense is a ``statistical defense" since it is based on the chances of the attacker guessing the random load address. The effectiveness of KASLR is thus proportional to the entropy of the random offset. It turns out that the current implementation of KASLR is severely limited in this randomness as the kernel modules can only be loaded within a 1GB range of the kernel image. Additionally, KASLR is further undermined by the presence of memory disclosure vulnerabilities. Memory leakages can be used to discover code gadgets at runtime in a technique known as \textit{Just-In-Time ROP (JIT-ROP)}.

In this thesis, we contributed towards kernel hardening by increasing the entropy of KASLR randomization and designing a code re-randomization technique for the Linux kernel. In Chapter~\ref{ch:pic} we discussed our implementation of position independent model (PIC) for the kernel modules. This contribution is submitted to  one of the Linux kernel hardening mailing lists and is currently under review~\cite{pie_patch_1:online,pie_patch_2:online}. Position independent kernel modules can be loaded anywhere in the 64-bit address space and makes guessing the base address of the module almost impossible.

The second major contribution of this thesis is the continuous re-randomization of kernel modules. We have described our implementation in detail in Chapter~\ref{ch:re_randomization}. Unlike existing user-space solutions, our technique uses a zero-copying method for moving data and code, and efficiently keeps track of and unmaps previously used address ranges. We are able to randomize a module and its stack at very high randomization frequencies (< 1ms) without significant performance degradation.

This is the first re-randomization implementation in kernel space. Kernel space creates additional challenges due to a low-level API, involving system calls, interrupt handling, and hardware access in device drivers. A code change at the operating system level has the potential to affect all the user space applications. We were thus very mindful of performance in our design. Our implementation is highly efficient with very little overhead (< 2\%) for re-randomization and completely negligible overhead for supporting extended KASLR with position-independent modules as compared to the vanilla Linux. We have evaluated our work in great detail in Chapter~\ref{ch:evaluation}.

Our re-randomization technique is highly efficient. The low overhead of our re-randomization thread and insignificant performance degradation of the randomized module is largely thanks to our \textit{zero-copy} approach. With the \textit{zero-copy} approach, the re-randomization thread only needs to create a new virtual address mapping instead of duplicating the memory pages, and since both the old and new address spaces remain mapped during the re-randomization process, the re-randomized module does not need to be paused for re-randomization. We believe this low overhead would help widespread adoption of our re-randomization technique.

\section{Future Work}
This thesis is the first effort to implement a re-randomization solution for kernel space and opens new avenues for further development in this area:

% Our work focused on the re-randomization of just the kernel modules. It was argued that by compiling most of the kernel as modules, the core kernel image can be reduced to a bare minimum. The small code base of the core kernel can be trusted to not have any bugs that leak memory. Without memory disclosure vulnerabilities in the core kernel, it is safe from JIT-ROP attacks. Our first proposal for future work is to reduce the trusted code base even further by having the kernel run on top of a thin hypervisor. The interface between a paravirtualized guest kernel and the hypervisor is similar to the interface between a kernel and a module. Our re-randomization technique could be extended to support re-randomization of the kernel running on a hypervisor.

We demonstrated our re-randomization technique by manually modifying the source code of the modules to support re-randomization. Making a module re-randomization friendly involves wrapping the interface between the kernel and the module. We propose a compiler plugin to identify and wrap all the functions and variables in the module that are exposed to the kernel. Linux kernel has more than 5000 modules, manually modifying the modules to be re-randomizable is not practical. Implementation of a compiler plugin to automate this process is paramount to reap the benefits of re-randomization.

Our work re-randomizes the kernel modules and the core kernel is left un-randomized. A randomized module is still capable of leaking a pointer to the core kernel. This is a security risk as the attacker can now harvest the code pages in the (un-randomized) core kernel and it might be possible to construct a JIT-ROP gadget consisting of the code from the core kernel alone. This can be prevented by encrypting the kernel references in the module. Pointers to the kernel can reside in the code or on the stack, both of which are already wrapped by our code and it is possible to add the encryption/decryption in the already existing wrappers. We leave the encryption of kernel pointers as a work for the future.

Our re-randomization technique provides limited support for \textit{global variable code pointers}. The value of a variable code pointer is evaluated at run-time. Since we do not unmap the old address space while a module function is under execution, a \textit{local variable pointer} reference never breaks, a global variable pointer can however break and must be handled uniquely during re-randomization. In contrast, a \textit{constant code pointer's} value is known at compilation time and there exists a corresponding relocation entry in the relocation table. In our implementation, we update all const pointers using the relocation table but a variable pointer must be handled differently. A naive approach is to \textit{wrap} all the functions referenced by the variable code pointers since function wrappers are not re-randomized, the pointers will remain valid after re-randomization. This approach introduces indirection to local function calls, can cause performance impact and hence may not be practical. In our research, none of the modules we worked with so far used variable global pointers, but such modules may exist. It is proposed that alternative techniques such as pointer tracking be explored to handle such cases.